name: 'Entur/Security/Code Scan'

on:
  workflow_call:
    inputs:
      use_setup_gradle:
        description: 'DEPRECATED. This is now autodetected and enabled if `build.gradle(.kt(s))` is found. Uses "gradle/action/setup-gradle" before running autobuild (Java/Kotlin only). Potentially speeds up build times if cache from main branch is utilized'
        default: false
        required: false
        type: boolean
      codeql_queries:
        description: 'Comma-separated list of queries for CodeQL to run. By default is set to security-extended.'
        default: "security-extended"
        required: false
        type: string
      job_runner:
        description: 'Customizable job runner for CodeQL jobs that require a little extra performance/memory. List of runners is available in [Confluence](https://enturas.atlassian.net/wiki/spaces/ESP/pages/4989059095/GitHub+Actions+Runners).'
        default: "ubuntu-24.04"
        required: false
        type: string
      gradle_opts:
        description: '[Gradle build options](https://docs.gradle.org/current/userguide/build_environment.html#environment_variables_reference) to pass on to the CodeQL scanner'
        default: "-Dorg.gradle.jvmargs=-Xmx4g"
        required: false
        type: string
    secrets:
      external_repository_token:
        description: 'Token to access the external repository mentioned in the codescan.yml file. Must have read access to the repository.'
        required: false
env:
  GITHUB_REPOSITORY: ${{ github.repository }}

jobs:
  input-validation:
    runs-on: ubuntu-24.04
    steps:
      - name: "Validate inputs"
        env:
          CODEQL_QUERIES: ${{ inputs.codeql_queries }}
          JOB_RUNNER: ${{ inputs.job_runner }}
        run: |
          python -c "import re
          import os
          codeql_queries = os.environ['CODEQL_QUERIES']
          regex_matches = re.findall(r'[^,\s?]+', codeql_queries)
          job_runner = os.environ['JOB_RUNNER']
          # Supported runners documented in confluence: https://enturas.atlassian.net/wiki/spaces/ESP/pages/4989059095/GitHub+Actions+Runners
          supported_runners = [
            'ubuntu-latest',
            'ubuntu-24.04',
            'ubuntu-22.04',
            'ubuntu-20.04',
            'windows-latest',
            'windows-2025',
            'windows-2022',
            'windows-2019',
            'macos-latest',
            'macos-15',
            'macos-14',
            'macos-13',
            'grp-ubuntu-24.04-2core-x64',
            'grp-ubuntu-24.04-4core-x64',
            'grp-ubuntu-24.04-8core-x64',
            'grp-ubuntu-24.04-16core-x64',
            'grp-ubuntu-22.04-4core-x64',
            'grp-ubuntu-24.04-2core-a64',
            ]
          
          if (len(regex_matches) <= 0):
            print('::error ::Invalid input. codeql_queries is set to invalid list. Use a comma-separated list: default, security-extended')
            exit(1)
          
          if (not job_runner in supported_runners):
            print('::error ::Invalid input. Supported runners are: ', supported_runners)
            exit(1)
          
          os.system('echo Validation passed')"
  upload-cached-results:
    runs-on:  ubuntu-24.04
    needs: input-validation
    outputs:
      skip_job_and_continue_scan: ${{ env.GHA_SECURITY_CODE_SCAN_SKIP_JOB_AND_CONTINUE_SCAN }}
    permissions:
      pull-requests: read
      actions: read
      security-events: write
      contents: read
    steps:
      - name: "Skip job if not triggered by a push to main/master"
        env:
          GITHUB_EVENT_NAME: ${{ github.event_name }}
          GITHUB_REF: ${{ github.ref }}
        run: |
          python -c "
          import os

          skip_job_and_continue_scan = False

          env_file = os.getenv('GITHUB_ENV')
          github_event_name = os.getenv('GITHUB_EVENT_NAME')
          github_ref = os.getenv('GITHUB_REF')

          if github_event_name != 'push' or (github_ref != 'refs/heads/main' and github_ref != 'refs/heads/master'):
            skip_job_and_continue_scan = True

          with open(env_file, 'a') as f:
            f.write('GHA_SECURITY_CODE_SCAN_SKIP_JOB_AND_CONTINUE_SCAN=' + str(skip_job_and_continue_scan) + '\n')
          "
      - name: "Get workflow run ID for matching PR"
        if: ${{ env.GHA_SECURITY_CODE_SCAN_SKIP_JOB_AND_CONTINUE_SCAN == 'False' }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_SHA: ${{ github.sha }}
        run: |
          python -c "
          import os
          import requests

          skip_job_and_continue_scan = False

          github_sha = os.getenv('GITHUB_SHA')
          github_token = os.getenv('GITHUB_TOKEN')
          github_repository = os.getenv('GITHUB_REPOSITORY')
          env_file = os.getenv('GITHUB_ENV')

          headers = {
            'Accept': 'application/vnd.github+json',
            'X-GitHub-Api-Version': '2022-11-28',
            'Authorization': f'token {github_token}'
          }
              
          five_recently_updated_closed_prs = requests.get(
            f'https://api.github.com/repos/{github_repository}/pulls',
            headers=headers,
            params={
              'state': 'closed',
              'per_page': '5',
              'sort': 'updated',
              'direction': 'desc'
            }
          )
          
          if five_recently_updated_closed_prs.status_code != 200:
            print('::warning ::Failed to fetch closed PRs, defaulting to running a new scan')
            skip_job_and_continue_scan = True
          else: 
            five_recently_updated_closed_prs = five_recently_updated_closed_prs.json()
            pr_head = None
            for closed_pr in five_recently_updated_closed_prs:
              merge_commit_sha = closed_pr.get('merge_commit_sha')
              if merge_commit_sha == github_sha:
                pr_head = closed_pr.get('head').get('sha')
                break
              
            if pr_head != None:
              workflow_runs = requests.get(
                f'https://api.github.com/repos/{github_repository}/actions/runs',
                headers=headers,
                params={
                  'head_sha': pr_head,
                  'event': 'pull_request',
                  'status': 'completed'
                }
              )

              if workflow_runs.status_code != 200:
                print('::warning ::Failed to fetch PR workflow runs, defaulting to running a new scan')
                skip_job_and_continue_scan = True
              else:
                workflow_runs = workflow_runs.json().get('workflow_runs', [])
                run_id = None
                for workflow_run in workflow_runs:
                  if workflow_run.get('path','').startswith('.github/workflows/codeql.yml'):
                    run_id = workflow_run.get('id')
                    
                    with open(env_file, 'a') as f:
                      f.write(f'GHA_SECURITY_CODE_SCAN_WORKFLOW_RUN_ID={run_id}\n')
                    
                    break
                if run_id is None:
                  print('::warning ::Failed to find a matching workflow run on the PR, defaulting to running a new scan')
                  skip_job_and_continue_scan = True
                
            else:
              print('::warning ::Failed to fetch a matching PR, defaulting to running a new scan')
              skip_job_and_continue_scan = True

          with open(env_file, 'a') as f:
            f.write('GHA_SECURITY_CODE_SCAN_SKIP_JOB_AND_CONTINUE_SCAN=' + str(skip_job_and_continue_scan) + '\n')
          "

      - name: "Download existing cached results from previous job (pr)"
        if: ${{ env.GHA_SECURITY_CODE_SCAN_SKIP_JOB_AND_CONTINUE_SCAN == 'False' }}
        uses: actions/download-artifact@v4
        with:
          run-id: ${{ env.GHA_SECURITY_CODE_SCAN_WORKFLOW_RUN_ID }}
          github-token: ${{ secrets.GITHUB_TOKEN }}
          path: "/home/runner/work/${{ env.GITHUB_REPOSITORY }}/results"

      - name: "Upload scan results"
        if: ${{ env.GHA_SECURITY_CODE_SCAN_SKIP_JOB_AND_CONTINUE_SCAN == 'False' }}
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: "/home/runner/work/${{ env.GITHUB_REPOSITORY }}/results"
          category: 'scan-results'

      - name: "Upload dependency graph"
        if: ${{ env.GHA_SECURITY_CODE_SCAN_SKIP_JOB_AND_CONTINUE_SCAN == 'False' }}
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          for file in /home/runner/work/$GITHUB_REPOSITORY/results/**/*.json ; do
            gh api /repos/$GITHUB_REPOSITORY/dependency-graph/snapshots --method POST --input $file
          done

  get-repository-metadata:
    if: ${{ needs.upload-cached-results.outputs.skip_job_and_continue_scan == 'True' }}
    runs-on: ubuntu-24.04
    needs: upload-cached-results
    outputs: 
      codeql_languages: ${{ env.GHA_SECURITY_CODE_SCAN_REPOSITORY_LANGUAGES_CQ }}
      semgrep_languages: ${{ env.GHA_SECURITY_CODE_SCAN_REPOSITORY_LANGUAGES_SEM }} 
      found_gradle: ${{ env.GHA_SECURITY_CODE_SCAN_FOUND_GRADLE }}
    steps:
      - name: "Checkout repository"
        uses: actions/checkout@v4

      - name: "Find Gradle Build"
        id: find-gradle-build
        run: |
          if [ $(find . -iname build.gradle -o -iname build.gradle.kts -o -iname build.gradle.kt | wc -l) -gt 0 ]; then
            echo "GHA_SECURITY_CODE_SCAN_FOUND_GRADLE=True" >> $GITHUB_ENV
          else
            echo "GHA_SECURITY_CODE_SCAN_FOUND_GRADLE=False" >> $GITHUB_ENV
          fi

      - name: "Get repository languages"
        id: get-repository-languages
        run: |
          REPO_FILE_TYPES=$(find . -path "./.git" -prune -o -type f -name "*.*" | sed "s|.*\.||" | tr "[:upper:]" "[:lower:]" | sort -u)
          export REPO_FILE_TYPES=$(echo "$REPO_FILE_TYPES" | jq -R -s -c 'split("\n")[:-1]')

          python -c "
          import os
          import json

          env_file = os.getenv('GITHUB_ENV', '')
          file_types = os.getenv('REPO_FILE_TYPES', '')
          try:
            file_types = json.loads(file_types)
          except:
            pass

          if not isinstance(file_types, list):
            file_types = []

          # See https://codeql.github.com/docs/codeql-overview/supported-languages-and-frameworks/
          codeql_languages = set()
          _codeql_mappings = {
            # Python
            'py': 'python',
            # Ruby
            'rb': 'ruby',
            'erb': 'ruby',
            'gemspec': 'ruby',
            'gemfile': 'ruby',
            # Swift
            'swift': 'swift',
            # Kotlin
            'kt': 'kotlin',
            # Java
            'java': 'java',
            # CSharp
            'sln': 'csharp',
            'csproj': 'csharp',
            'cs': 'csharp',
            'cshtml': 'csharp',
            'xaml': 'csharp',
            # Golang
            'go': 'go',
            # CPP
            'cpp': 'cpp',
            'c++': 'cpp',
            'cxx': 'cpp',
            'hpp': 'cpp',
            'hh': 'cpp',
            'h++': 'cpp',
            'hxx': 'cpp',
            'c': 'cpp',
            'cc': 'cpp',
            'h': 'cpp',
            # Typescript
            'ts': 'javascript-typescript',
            'tsx': 'javascript-typescript',
            'mts': 'javascript-typescript',
            'cts': 'javascript-typescript',
            # Javascript
            'js': 'javascript-typescript',
            'jsx': 'javascript-typescript',
            'mjs': 'javascript-typescript',
            'es': 'javascript-typescript',
            'es6': 'javascript-typescript',
            'vue': 'javascript-typescript',
            'ejs': 'javascript-typescript',
            'htm': 'javascript-typescript',
            'html': 'javascript-typescript',
            'xhtm': 'javascript-typescript',
            'xhtml': 'javascript-typescript',
            # Misc
            'yml': 'javascript-typescript',
            'yaml': 'javascript-typescript',
            'raml': 'javascript-typescript',
            'xml': 'javascript-typescript',
            'json': 'javascript-typescript',
            'njk': 'javascript-typescript',
            'hbs': 'javascript-typescript',
          }
          
          semgrep_languages = set()
          _semgrep_mappings = {
            # Scala
            'scala': 'scala',
            'sc': 'scala',
          }

          for file_type in file_types:
            if (lang := _codeql_mappings.get(file_type, None)) is not None:
              codeql_languages.add(lang) 
            if (lang := _semgrep_mappings.get(file_type, None)) is not None:
              semgrep_languages.add(lang)

          codeql_languages = list(codeql_languages)
          semgrep_languages = list(semgrep_languages)

          with open(env_file, 'a') as f:
            f.write(f'GHA_SECURITY_CODE_SCAN_REPOSITORY_LANGUAGES_CQ={str(codeql_languages)}\n')
            f.write(f'GHA_SECURITY_CODE_SCAN_REPOSITORY_LANGUAGES_SEM={str(semgrep_languages)}\n')
          "

  semgrep-analysis:
    # See https://docs.github.com/en/code-security/code-scanning/creating-an-advanced-setup-for-code-scanning/customizing-your-advanced-setup-for-code-scanning#scanning-on-push
    # If we found a language, and the event is not a push made by dependabot on a PR
    if: ${{ needs.get-repository-metadata.outputs.semgrep_languages != '[]' && (github.event != 'push' || (github.event == 'push' && github.actor != 'dependabot[bot]')) }}
    runs-on: ubuntu-24.04
    needs: get-repository-metadata
    permissions:
      # Semgrep - required for all workflows
      security-events: write
      # Semgrep - only required for workflows in private repositories
      actions: read
      contents: read
    strategy:
      fail-fast: false
      matrix:
        language: ${{ fromJson(needs.get-repository-metadata.outputs.semgrep_languages) }}
    steps:
      - name: "Checkout repository"
        uses: actions/checkout@v4

      - name: "Set up Semgrep"
        run: |
          python3 -m pip install semgrep

      - name: "Scan with Semgrep"
        run: |
          semgrep scan --sarif \
          --sarif-output=semgrep.sarif \
          --no-secrets-validation \
          --metrics=off \
          --config=p/scala \
          --exclude=*.c \
          --exclude=*.h \
          --exclude=*.cpp \
          --exclude=*.cxx \
          --exclude=*.cc \
          --exclude=*.hxx \
          --exclude=*.cs \
          --exclude=*.go \
          --exclude=*.java \
          --exclude=*.js \
          --exclude=*.ts \
          --exclude=*.kt \
          --exclude=*.py \
          --exclude=*.rb \
          --exclude=*.tf \
          --exclude=*.json \
          --exclude=*.swift

      - name: "Upload Semgrep report"
        id: upload-semgrep-report
        uses: github/codeql-action/upload-sarif@v3
        with: 
          sarif_file: semgrep.sarif
          category: 'semgrep-scan'

      - name: "Upload Semgrep report as artifact"
        uses: actions/upload-artifact@v4
        with:
          name: semgrep-${{ matrix.language }}-sarif
          path: semgrep.sarif
          overwrite: true

  codeql-analysis:
    # See https://docs.github.com/en/code-security/code-scanning/creating-an-advanced-setup-for-code-scanning/customizing-your-advanced-setup-for-code-scanning#scanning-on-push
    # If we found a language, and the event is not a push made by dependabot on a PR
    if: ${{ needs.get-repository-metadata.outputs.codeql_languages != '[]' && (github.event != 'push' || (github.event == 'push' && github.actor != 'dependabot[bot]')) }}
    # Runners are selected by labels: (default when you pass a string directly to runs-on) or group: "grp-runner". This snippet of code uses JSON to construct the group: object if the runner name starts with "grp-"
    runs-on:  ${{ startsWith(inputs.job_runner, 'grp-') && fromJSON(format('{{"group":"{0}"}}', inputs.job_runner)) || inputs.job_runner }}
    needs: get-repository-metadata
    permissions:
      # CodeQL - required for all workflows
      security-events: write
      # CodeQL - only required for workflows in private repositories
      actions: read
      contents: write
    strategy:
      fail-fast: false
      matrix:
        language: ${{ fromJson(needs.get-repository-metadata.outputs.codeql_languages) }}
    steps:
      - name: "Checkout repository"
        uses: actions/checkout@v4

      - name: "Set up Gradle for Java/Kotlin"
        if: needs.get-repository-metadata.outputs.found_gradle == 'True' && (matrix.language == 'kotlin' || matrix.language == 'java')
        uses: gradle/actions/setup-gradle@v4
        with: 
          cache-read-only: true  # Force read only, even in main
          add-job-summary: 'on-failure'
          dependency-graph: ${{ github.ref_name == github.event.repository.default_branch && 'generate-submit-and-upload' || 'generate-and-upload' }}

      - name: "Initialize CodeQL for Java/Kotlin"
        if: matrix.language == 'kotlin' || matrix.language == 'java'
        uses: github/codeql-action/init@v3
        with:
          languages: ${{ matrix.language }}
          build-mode: autobuild
          queries: ${{ inputs.codeql_queries }}

      - name: "Initialize CodeQL"
        if: matrix.language != 'java' && matrix.language != 'kotlin'
        uses: github/codeql-action/init@v3
        with:
          languages: ${{ matrix.language }}
          queries: ${{ inputs.codeql_queries }}

      - name: "Perform CodeQL Analysis"
        id: codeql-analysis
        uses: github/codeql-action/analyze@v3
        with:
          category: "/language:${{ matrix.language }}"
        env:
          ARTIFACTORY_AUTH_USER: ${{ secrets.ARTIFACTORY_AUTH_USER }}
          ARTIFACTORY_USER: ${{ secrets.ARTIFACTORY_AUTH_USER }} # Kept for backwards compatability
          ARTIFACTORY_AUTH_TOKEN: ${{ secrets.ARTIFACTORY_AUTH_TOKEN }}
          ARTIFACTORY_URL: ${{ vars.ARTIFACTORY_URL }}
          ARTIFACTORY_APIKEY: ${{ secrets.ARTIFACTORY_APIKEY }}
          GRADLE_OPTS: ${{ inputs.gradle_opts }}
          IS_CODEQL_SCAN: true

      - name: "Get repository name"
        run: |
          REPOSITORY_NAME=$(echo "${GITHUB_REPOSITORY}" | cut -d'/' -f2)
          echo "REPOSITORY_NAME=$REPOSITORY_NAME" >> $GITHUB_ENV

      - name: "Upload CodeQL report as artifact"
        uses: actions/upload-artifact@v4
        with:
          name: codeql-${{ matrix.language }}-sarif
          path: "/home/runner/work/${{ env.REPOSITORY_NAME }}/results"
          overwrite: true

  allowlist-code-scan-alerts:
    needs: [codeql-analysis, semgrep-analysis]
    runs-on: ubuntu-24.04
    permissions:
      # required to read and update code scan alerts
      security-events: write
      # required to checkout the repository
      contents: read
    steps:
      - name: Install dependencies
        shell: bash
        run: |
          cat > requirements.txt << EOF
          Cerberus == 1.3.5 --hash=sha256:7649a5815024d18eb7c6aa5e7a95355c649a53aacfc9b050e9d0bf6bfa2af372 --hash=sha256:81011e10266ef71b6ec6d50e60171258a5b134d69f8fb387d16e4936d0d47642
          EOF
          pip install --only-binary=:all: --require-hashes -r requirements.txt
          rm requirements.txt

      - name: "Checkout repository"
        uses: actions/checkout@v4

      - name: "Check if allowlist files exist"
        env:
          GHA_SECURITY_CODE_SCAN_EXTERNAL_REPOSITORY_TOKEN: ${{ secrets.external_repository_token }}
        run: |
          python -c "
          import os
          import re
          import requests
          import base64
          import yaml

          external_token = os.getenv('GHA_SECURITY_CODE_SCAN_EXTERNAL_REPOSITORY_TOKEN')
          env_file = os.getenv('GITHUB_ENV')

          _config_file_names = ('codescan.yml', 'codescan.yaml')
          _file_location = '.entur/security'
          
          config_path = ''
          config_path_external = ''
          external_repository = ''

          for file_name in _config_file_names:
            try:
              tmp_config_path = os.path.join(_file_location, file_name)
              with open(tmp_config_path, 'r') as f:
                config_path = tmp_config_path
                config = yaml.safe_load(f)

                spec = config.get('spec', None)
                spec = {} if spec is None else spec
                inherit = spec.get('inherit', None)
                inherit = '' if inherit is None else inherit

                tmp_external_repository = str(inherit)
                if tmp_external_repository != '' and not re.match(r'^[\w\.-]+$', tmp_external_repository):
                  print(f'::warning ::Failed to fetch allowlist file from external repository due to name containing illegal characters ({tmp_external_repository})')
                else:
                  external_repository = tmp_external_repository
                
              break
            except IOError:
              pass
              
          if config_path == '':
            print(f'::notice ::Allowlist file not found in current repository, skipping remaining steps')
        
          if external_repository != '':
            headers = {
              'Accept': 'application/vnd.github+json',
              'X-GitHub-Api-Version': '2022-11-28',
              'Authorization': f'token {external_token}',
            }

            for file_name in _config_file_names:
              response = requests.get(f'https://api.github.com/repos/entur/{external_repository}/contents/{_file_location}/{file_name}', headers=headers)

              if response.status_code != 404 and response.status_code != 200:
                print(f'::warning ::Failed to fetch allowlist file from external repository ({response.status_code} - {response.reason})')
                break
              if response.status_code == 200:
                config_path_external = os.path.join(_file_location, 'external_codescan.yml')
                with open(config_path_external, 'w') as f:
                  f.write(base64.b64decode(response.json().get('content', '')).decode('utf-8'))
                break
            
            if config_path_external == '':
              print(f'::warning ::Failed to find an allowlist in external repository')
                
          with open(env_file, 'a') as f:
            f.write(f'GHA_SECURITY_CODE_SCAN_CONFIG_PATH={config_path}\n')
            f.write(f'GHA_SECURITY_CODE_SCAN_CONFIG_PATH_EXTERNAL={config_path_external}\n')
          "

      - name: "Validate allowlist file(s)"
        id: validate_allowlists
        if: ${{ env.GHA_SECURITY_CODE_SCAN_CONFIG_PATH != '' }}
        run: |
          python -c "
          import yaml
          from cerberus import Validator
          import sys
          import os

          config_path = os.getenv('GHA_SECURITY_CODE_SCAN_CONFIG_PATH', '')
          config_path_external = os.getenv('GHA_SECURITY_CODE_SCAN_CONFIG_PATH_EXTERNAL', '')

          _schema = {
            'apiVersion': {'type': 'string', 'required': True, 'allowed': ['entur.io/securitytools/v1']},
            'kind': {'type': 'string', 'required': True, 'allowed': ['CodeScanConfig']},
            'metadata': {
              'type': 'dict', 
              'required': True,
              'schema': {
                'id' : {'type': 'string', 'required': True},
                'name': {'type': 'string', 'required': True},
                'owner': {'type': 'string', 'required': True},
              },
            },
            'spec': {
              'type': 'dict',
              'required': True,
              'nullable': True,
              'schema': {
                'inherit': {'type': 'string', 'required' : False},
                'allowlist': {
                  'required' : False,
                  'nullable': True,
                  'type': 'list',
                  'schema': {
                    'type': 'dict',
                    'schema': {
                      'cwe': {'type': 'string', 'required': True},
                      'comment': {'type': 'string', 'required': True},
                      'reason': {'type': 'string', 'required': True, 'allowed': ['false_positive', 'wont_fix', 'test']},
                    },
                  },
                },
              },
            },
          }
          v = Validator(_schema)
          
          with open(config_path, 'r') as f:
            data = yaml.safe_load(f)
            if not v.validate(data):
                print(f'::error ::Allowlist file is invalid. Here are the errors: {v.errors}')
                sys.exit(1)

          if config_path_external != '':
            with open(config_path_external, 'r') as f:
              data = yaml.safe_load(f)
              if not v.validate(data):
                  print(f'::error ::External allowlist file is invalid. Here are the errors: {v.errors}')
                  sys.exit(1)
          "
            
      - name: "Allowlist code scan alerts"
        if: ${{ steps.validate_allowlists.outcome == 'success' }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          python -c "
          import requests
          import yaml
          import json
          import os
          import sys
          import time

          repository = os.getenv('GITHUB_REPOSITORY')
          token = os.getenv('GITHUB_TOKEN')

          config_path = os.getenv('GHA_SECURITY_CODE_SCAN_CONFIG_PATH', '')
          config_path_external = os.getenv('GHA_SECURITY_CODE_SCAN_CONFIG_PATH_EXTERNAL', '')
    
          headers = {
            'Accept': 'application/vnd.github+json',
            'X-GitHub-Api-Version': '2022-11-28',
            'Authorization': f'token {token}',
          }

          merged_allowlist = {}
          reason_mapping = {
            'false_positive': 'false positive',
            'wont_fix': 'won\'t fix',
            'test': 'used in tests',
          }

          for file_path in (config_path_external, config_path):
            try:
              with open(file_path, 'r') as f: 
                config = yaml.safe_load(f)

                spec = config.get('spec', None)
                spec = {} if spec is None else spec
                allowlist = spec.get('allowlist', None)
                allowlist = [] if allowlist is None else allowlist
                
                for element in allowlist:
                  cwe = element.get('cwe', '')
                  cwe_tag = f'external/cwe/{cwe}'
                  merged_allowlist[cwe_tag] = {
                    'comment': element.get('comment', ''),
                    'reason': reason_mapping[element.get('reason', '')]
                  }
                  
              break
            except IOError:
              pass
          
          if len(merged_allowlist) > 0:
            url = f'https://api.github.com/repos/{repository}/code-scanning/alerts?ref=${{ github.ref }}&per_page=100&state=open'
            while True:
              response = requests.get(url, headers=headers)

              if response.status_code != 200:
                print(f'::error ::Could not get code scan alerts ({response.status_code} - {response.reason})')
                sys.exit(1)

              alerts = response.json()
              for alert in alerts:
                for cwe_tag, data in merged_allowlist.items():
                  if cwe_tag in alert.get('rule', {}).get('tags', []):
                    alert_number = alert.get('number', '')
                    patch_url = f'https://api.github.com/repos/{repository}/code-scanning/alerts/{alert_number}'
                    data_to_send = {
                      'state': 'dismissed',
                      'dismissed_reason': data.get('reason', ''),
                      'dismissed_comment': data.get('comment', '')
                    }

                    while True:
                      response_patch = requests.patch(patch_url, headers=headers, json=data_to_send)
                      x_ratelimit_remaining = response_patch.headers.get('x-ratelimit-remaining')
                      
                      if (response_patch.status_code == 403 or response_patch.status_code == 429) and x_ratelimit_remaining == '0':
                        x_ratelimit_reset = response_patch.headers.get('x-ratelimit-reset')
                        current_time = int(time.time())
                        reset_time = int(x_ratelimit_reset) - current_time
                        
                        time.sleep(reset_time)

                      else:
                        break
                      
              links = response.headers.get('Link', '')
              link_next_j = links.find('>; rel=\"next\"')

              if link_next_j == -1:
                break

              link_next_i = links.rfind('<', 0, link_next_j)
              if link_next_i == -1:
                break

              url = links[link_next_i + 1:link_next_j]
          "

  check-for-critical-alerts:
    runs-on: ubuntu-24.04
    if: ${{ always() }}
    needs: [allowlist-code-scan-alerts]
    permissions: 
      security-events: read # required to read code scan alerts
      issues: write # required for creating issues, and/or adding issue comments
      pull-requests: write # required for creating comments on pull requests
    steps: 
    - name: "Get critical code scan alerts"
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        set +e # Do not exit if a command fails
        get_alerts () {
          alerts="$(gh api \
          --method GET \
          -H 'Accept: application/vnd.github+json' \
          -H 'X-GitHub-Api-Version: 2022-11-28' \
          /repos/${GITHUB_REPOSITORY}/code-scanning/alerts \
          -F severity="$1" -F state='open' -F ref='${{ github.ref }}' -F per_page='100' -F tool_name="$2" --paginate)"
          alerts_exit_code=$? # Save exit code from gh api command
        }
        get_alerts "error" "Semgrep OSS"
        semgrep_alerts=$alerts
        
        get_alerts "critical" "CodeQL"
        codeql_alerts=$alerts
        
        if [ $alerts_exit_code != 0 ]; then
            echo "Failed to get alerts from Github. The previous upload vulnerability report step might have failed to be processed/uploaded. Try running the job again"
            echo '## Code Scan - Failed to get alerts.
            Upload vulnerability report step might have failed to be processed/uploaded.
            Try running the job again' >> $GITHUB_STEP_SUMMARY
            exit 1
        else
          if [ "$semgrep_alerts" == "[]" ] && [ "$codeql_alerts" == "[]" ]; then
            echo 'GHA_SECURITY_CODE_SCAN_CREATE_ALERT_COMMENT='False >> $GITHUB_ENV
          else
            echo 'GHA_SECURITY_CODE_SCAN_CREATE_ALERT_COMMENT='True >> $GITHUB_ENV
          fi
        fi

    - name: "Print to job summary if critical alerts are found"
      if: ${{ env.GHA_SECURITY_CODE_SCAN_CREATE_ALERT_COMMENT == 'True' }}
      env:
        REPOSITORY: ${{ github.repository }}
        GIT_REF: ${{ github.ref }}
      run: |
        echo '## ⛔ Code Scan - Critical Vulnerabilities ⛔
        **Code scan detected critical vulnerabilities in the code that needs to be addressed.**
        ### Results
        The scan results can be found [here](https://github.com/'"$REPOSITORY"'/security/code-scanning?query=is%3Aopen+ref%3A'"$GIT_REF"')
        ### Allowlist
        Use the allowlist if you want to ignore vulnerabilities that do not affect the repository.  
        See the [Code Scan documentation](https://github.com/entur/gha-security/blob/main/README-code-scan.md#allow-lists) on how to use allowlist.' >> $GITHUB_STEP_SUMMARY

    - name: "Create comment on pull request if critical alerts are found"
      if: ${{ env.GHA_SECURITY_CODE_SCAN_CREATE_ALERT_COMMENT == 'True' && github.event_name == 'pull_request' }}
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        gh pr comment ${{ github.event.pull_request.number }} --repo $GITHUB_REPOSITORY -b "## ⛔ Code Scan - Critical Vulnerabilities ⛔
        **Code scan found critical vulnerabilities in the code that needs to be addressed.**
        ### Results
        The scan results can be found [here](https://github.com/${GITHUB_REPOSITORY}/security/code-scanning?query=is%3Aopen+pr%3A${{ github.event.pull_request.number }})
        ### Allowlist
        Use the allowlist if you want to ignore vulnerabilities that do not affect the repository.  
        See the [Code Scan documentation](https://github.com/entur/gha-security/blob/main/README-code-scan.md#allow-lists) on how to use allowlist."